
# 프로젝트 분석 보고서: ProjectDS

## 1. 프로젝트 구조 분석

본 프로젝트는 언리얼 엔진을 사용한 3인칭 액션 RPG로, 커밋 히스토리와 소스 코드 구조를 통해 다음과 같은 아키텍처를 파악할 수 있습니다.

- **Manager 기반 아키텍처**: `GameManager`, `DataManager`, `UnitManager`, `UIManager` 등 싱글톤 매니저 클래스들이 게임의 핵심 로직을 관리합니다. 이는 각 기능의 역할을 명확히 분리하고 코드의 응집도를 높이는 효율적인 구조입니다.
    - **DataManager**: 게임에 필요한 각종 데이터(아이템, 스킬, 몬스터 정보 등)를 `DataTable` 형태로 관리하여, 데이터 기반의 개발을 용이하게 합니다.
    - **UnitManager**: 게임 내 모든 유닛(플레이어, 적)의 생성, 소멸, 추적을 중앙에서 관리합니다.
    - **BattleSubSystem**: 전투와 관련된 복잡한 로직(충돌 계산, 데미지 적용 등)을 별도의 서브시스템으로 분리하여 관리의 효율성을 높였습니다. 특히 `BossBattleSubSystem`을 따로 두어 보스전의 복잡한 페이즈별 로직을 독립적으로 처리합니다.

- **컴포넌트 기반 유닛 설계**: `Unit`(캐릭터)의 기능들이 `StatController`, `InventoryController`, `LockOnController`, `CrowdControlController` 등 독립적인 컨트롤러 컴포넌트로 분리되어 있습니다. 이는 기능의 재사용성과 확장성을 높이는 현대적인 게임 개발 패턴입니다.

- **데이터 기반 시스템**: `DataTable`을 적극적으로 활용하여 `SkillInfo`, `ItemInfo`, `MonsterData` 등을 관리합니다. 이를 통해 기획자는 코드 수정 없이 데이터 테이블 수정만으로 게임 밸런스와 콘텐츠를 쉽게 조절할 수 있습니다.

## 2. 기술적 도전 과제 및 해결 사례 (포트폴리오용)

프로젝트 진행 과정에서 마주한 주요 기술적 도전 과제와 그 해결 과정은 다음과 같습니다.

### 1. 보스전 페이즈(Phase) 시스템 구현

- **도전 과제**: 보스의 체력에 따라 공격 패턴과 행동 양식이 동적으로 변화하는 다중 페이즈 시스템을 구현해야 했습니다. 이는 단순한 AI 상태 변화를 넘어, 보스의 스킬셋, 시각 효과(VFX), 사운드, AI 로직 전체를 전환해야 하는 복잡한 작업이었습니다.
- **해결 과정**:
    - `BossBattleSubSystem`을 도입하여 보스전의 상태를 독립적으로 관리했습니다.
    - 보스의 체력을 지속적으로 모니터링하고, 특정 체력 이하로 떨어졌을 때 페이즈 전환 이벤트(`OnPhaseChanged`)를 발생시켰습니다.
    - 이 이벤트를 받아 `BossAIController`는 새로운 페이즈에 맞는 Behavior Tree를 로드하거나, 기존 트리의 특정 분기로 전환하여 행동 패턴을 변경했습니다.
    - `DataManager`에 페이즈별 스킬 정보를 `DataTable`로 정의하여, 페이즈 전환 시 해당 데이터를 읽어와 스킬 구성을 동적으로 변경했습니다.
    - 페이즈 전환 시점에 맞춰 애니메이션 몽타주, 파티클 이펙트, 사운드를 재생하여 극적인 연출을 구현했습니다. (Commit: `e1fe1e3`, `ef4fbea`)

### 2. 정교한 락온(Lock-on) 타겟팅 시스템 개발

- **도전 과제**: 다수의 적과 싸우는 액션 게임의 특성상, 플레이어가 원하는 적을 정확히 조준하고 시점을 안정적으로 유지하는 락온 시스템이 필수적이었습니다. 특히 락온 대상이 죽거나 시야에서 사라졌을 때의 자연스러운 처리, 대상 변경 기능 등이 필요했습니다.
- **해결 과정**:
    - `LockOnController` 컴포넌트를 개발하여 락온 관련 로직을 캡슐화했습니다.
    - 플레이어 전방의 일정 범위 내 적들을 탐색하고, 그중 화면 중앙에 가장 가까운 적을 우선 타겟으로 선정하는 로직을 구현했습니다.
    - 락온된 대상이 죽었을 때, 대상의 `OnDeath` 델리게이트에 함수를 바인딩하여 자동으로 락온을 해제하도록 구현했습니다. (Commit: `edc44c7`)
    - 대상이 없을 때는 카메라를 부드럽게(smoothly) 플레이어의 등 뒤로 되돌리는 로직을 추가하여 사용자 경험을 향상시켰습니다. (Commit: `70f86a5`)
    - 입력을 통해 락온 대상을 좌/우의 다른 적으로 변경하는 기능을 추가하여 편의성을 높였습니다. (Commit: `b5c1854`)

### 3. 데이터 기반의 동적 스킬 및 충돌 시스템

- **도전 과제**: 다양한 형태(원형, 부채꼴, 박스)와 범위를 가진 스킬들을 효율적으로 관리하고, 각 스킬에 맞는 정확한 충돌 판정을 구현해야 했습니다. 스킬이 추가될 때마다 코드를 수정하는 방식은 비효율적이었습니다.
- **해결 과정**:
    - `SkillInfo`와 `CollisionInfo` 데이터 테이블을 생성하여 스킬의 모든 속성(데미지, 범위, 형태, 이펙트 등)을 정의했습니다.
    - `BattleSubSystem`이 이 테이블 데이터를 캐싱하여 사용하도록 설계했습니다.
    - 애니메이션 노티파이(AnimNotify) 시점에 `SkillID`를 받아 `BattleSubSystem`에 충돌 처리를 요청하면, 서브시스템이 `CollisionInfo`를 참조하여 해당 스킬에 맞는 모양(Sphere, Box, Cone)과 크기로 충돌 영역을 동적으로 생성하고 충돌 검사를 수행했습니다. (Commit: `47fe920`, `b14791e`)
    - 이를 통해 애니메이터나 기획자가 코드 수정 없이 노티파이와 데이터 테이블 수정만으로 새로운 스킬의 판정을 구현할 수 있는 워크플로우를 구축했습니다.

### 4. 거리 기반의 지능형 AI 전투 패턴 구현

- **도전 과제**: 적 AI가 플레이어와의 거리에 따라 다른 전투 패턴(근접 공격, 원거리 공격, 회피 등)을 사용하도록 하여 단조로운 전투를 피해야 했습니다.
- **해결 과정**:
    - `EnemyAIController` 내에 `BattleMode`라는 상태 변수(e.g., `EBattleMode::CloseRange`, `EBattleMode::LongRange`)를 도입했습니다.
    - AI의 Behavior Tree는 매 틱마다 플레이어와의 거리를 체크하여 `BattleMode`를 갱신하는 서비스를 실행합니다.
    - Behavior Tree 내에서 `BattleMode` 값에 따라 다른 서브트리(Sub-tree)로 분기하도록 설계했습니다. 예를 들어, `LongRange` 모드일 때는 원거리 공격 노드를, `CloseRange` 모드일 때는 근접 공격 노드를 실행하여 상황에 맞는 동적인 전투를 구현했습니다. (Commit: `06f3375`)
